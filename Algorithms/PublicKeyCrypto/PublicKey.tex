\lab{Algorithms}{Public Key Cryptography}{RSA}
\objective{Understand the fundamentals of RSA public key cryptography.}

How do you exchange information over unsecure, public channels fo communcations?
Historically, the answer has been to use some sort of cipher to obscure the meaning of a message.
Many ciphers use a secret key which was used to encrypt and decrypt any sent messages.
However, the problem then became how to keep the key secret and known only to the authorized recipients
If the key was obtained by any attackers, then the whole cipher was compromised.

Public key cryptography provides a way for each person to have their own keys.
There is no need to transmit any keys.
There are several public key crypto systems, but one of the most popular is RSA.
In the RSA system, each person has a public key and a private key.
The security of the system is founded in the difficulty of factoring large numbers.

To make RSA feasible, we need the following two results.
\section*{Fast Modular Exponentiation}
How would we compute $8^{3039} \pmod{38}$?
We understand that one possible way of computing it would be
\[
8*8*8*8*\dots (3034 \text{ more times}) *8 \pmod{38}
\]
Calculating $8^8 = 16777216$!
Multiplying by $8$ each time leads to an enormous number which will finally be modded by $38$.
This will yield the answer $8^{3039} \equiv 18 \pmod{38}$.
However, we end up taking the mod of
\bignumber{
309364494429910569224074158373245871320261088338818839809516116319683937337824694639797484392553145921311162969795314687577878753945880788983648152672594156300105725702103009637521625346699102295126628430309215629345466680377322721095287151119548805982396859332324466726353415424546071554284880207769127903957788381101261257400404091967745307542578110867428754531803501942215597076795550293680355286384571026107363456179332767989089566141431697627745495677144792091971662774633776798836200145568167185652541589550330302123213629924085364016735796793885830988154309607850311898139167789375097602259381382514738805341423499721915190150925750938698512580223390713732486217483835134483607572569965309788063985462802989666308187452193771262040654008343868553985290751031810255880576927481663915122694568633300196828561130700545356768269280582187434534587197790354825628606664089599620772968794242997194172311333478650892585491058221492045784537878309096904862622869880014885551768545206544797116976074726344672493362695001481246347025291097347071973382250375852943818394695506599746738528681847642588807064370431862121741365676061233863942639392094469784702981369030250646812998461185633133467848986680638596314385337594273706701821800747548879458720019986682149146178685620334639282770904752914338826080860394274054737727003947974330004250338618843866592996192592830428423557692067769040096619828579638668400776746787256297380969946092270211524838778326711459996610641780767409606310642567660939458268000436251149254496654579604110657406568924179426470575501715013699220499232592923604442084548714023334631240982218358709753276420169139766405851160552486985275545321622498920625449176748818750710269694571141052545377449900581511454744120583816689607736846690232243393522342511186883894978304133143561241609992101663224030378192256447359110223366534769148676617094540983847686052547554325114060171112942592559843266410180826907725652938458795170564048598915083447841405646218536748421562297392006736931061215283387476058020858472263277569528893717205547768782193687332954106775185844759834817560367256170008829121239203290178930273790225520822117811256113731460192291020890045339125107445596097502290088470399019377018999927146843758630858434307599598944654022610984394045354982335998229899355619105759758299408946577503586191826628867086134833399462086170520653130187774421326917599586226987836827057382874569968377835965522866175136706353981372627380585333516862107939980976386191599775970968090528612429851830568492291708701684485778958412327410974829592671072270914520010627822203247436654805140288488799865758452727784199585943373090512798063591996432420346051711662890727147789447431115400966915927049391788520615997937437506978273276117123072}
Imagine if our exponent was hundreds of digits!
We could quickly run out of memory.

We can avoid dealing such huge numbers by doing the mod after each multiplication.
Doing the mod after each multiplication means that the largest number we have to deal with in this problem is 240.
In general, we wouldn't have to work with anything larger than $37^{2}$.
However, if we still have large exponent, the loop doing the multiplication would still have to run $3039$ iterations.

\begin{problem}
Write a function that will calculate $b^{e} \pmod{m}$.
Do not use Python's built-in power function.
\label{prob:naivepower}
\end{problem}

We need a faster better way.
The most common method of modular exponentiation is the \emph{right-to-left binary method}.
The essence of this method is to use the binary representation of the exponent.
We can quickly calculate the power up to the nearest power of two of the exponent.
This we simply calculate the remaining part the naieve way.

Calculating a modular exponent in this way leads to a very desirable $O(\log_2 e)$ runtime performance, where $e$ is the exponent.

\begin{problem}
Write a function that will perform modular exponentiation using the right-to-left binary method.
Compare the performance of \ref{prob:naivepower} and your new implementation.
Note that Python's built-in function, pow, performs this type of fast modular exponentiation.
We expect you to use it over your own implementation in the future.
\label{prob:rlbpower}
\end{problem}

\section*{Fermat's Little Theorem}
An integral part of RSA relies on working with large prime numbers.
Prime numbers are numbers that are only divisible by 1 and the number itself.
In the RSA algorithms, we need to start with two prime numbers, $p$ and $q$.
We multiply these numbers to get $n=pq$ which is our modulus.
However, if $n$ is not that big, we can easily factor it, defeating the whole purpose of RSA.
The security of RSA largely reduces down to how well we choose starting primes.
If we pick primes that are too small, we sacrifice security.
How do we pick large primes?
We can use sieves to generate primes, but doing so would take lots of time and lots of memory.
It would be better if we could choose a number and determine if it is prime or not.

Fortunately, mathematics has developed a few tools that can help us out.
One of the first steps was given by Fermat.
\begin{theorem}[Fermat's Little Theorem]
If $p$ is prime, then for a natural number $a$, $a^{p-1} - 1 \equiv 0 \pmod{p}$
\end{theorem}
But, to use this we have start with a prime number.
However, if we have a candidate for $p$ and it satisifies the condition can we say anything about $p$?
The answer is yes, but we cannot say that $p$ is prime.
We can only say that $p$ might be prime.
\begin{example}
Suppose $p=37$.
We want to know if $p$ is prime.  We choose $a=8$.
\[
8^{36} - 1 \equiv 0 \pmod{37} 
\]
We call $8$ the witness number.  Think of as, \emph{$8$ says that $37$ is prime}.
This is the probabilistic part of Fermat's theorem.
We try enough witness numbers until we are convinced that our candidate number is prime.
Trying enough prime numbers, we will eventually be convinced that $37$ is prime, which it is.
\end{example}

\begin{example}
Let's check the primality of $1729$.
We will use $a=145$ as a witness number.
\[
145^{1728} \equiv 1 \pmod{1729}
\]
It appears that $1729$ is prime.
Let's try another witness number, $a=583$.
\[
583^{1728} \equiv 1 \pmod{1729}
\]
Let's try one last witness number, $a=945$.
\[
945^{1728} \equiv 742 \not\equiv 1 \pmod{1729}
\]
We have a problem.  
Our candidate is not behaving like we would expect a prime to behave.
But several witnesses verified that our number was prime.  What happened?
Our number, $1729$ is not really prime.  Its prime factors are $7$, $13$, and $19$. 
It is a special number called a Carmichael number.
Because of these numbers, we have to be careful with Fermat's Little Theorem.
More stringent primality tests exist, but are beyond the scope of this lab.
\end{example}

\section*{RSA Algorithm}
Bob wants to send a secret message to Alice.
Eve is trying to intercept this message.
Bob and Alice agree to use RSA to exchange the secret message.
Bob and Alice need to generate their keys.
Each generate a pair of keys, a private and a public one.
Both Bob and Alice need to keep their private keys secret.
Anyone with Alice's public key can send her a message that only she can decrypt.
Bob obtains a copy of Alice's pulic key and encrypt his message using it.
Alice decrypts Bob's message using her private key, and reads the message.

RSA involves generating a private key and a public key.

We begin by finding two large prime numbers.
By large, we mean several hundred digits.

\begin{problem}
 Find two large prime numbers that are near each other
\end{problem}


