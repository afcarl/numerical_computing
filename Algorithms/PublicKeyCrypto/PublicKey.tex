\lab{Algorithms}{Public Key Cryptography}{RSA}
\objective{Understand the fundamentals of RSA public key cryptography.}

How do you exchange information over unsecure, public channels fo communcations?
Historically, the answer has been to use some sort of cipher to obscure the meaning of a message.
Many ciphers use a secret key which was used to encrypt and decrypt any sent messages.
However, the problem then became how to keep the key secret and known only to the authorized recipients
If the key was obtained by any attackers, then the whole cipher was compromised.

Public key cryptography provides a way for each person to have their own keys.
There is no need to transmit any keys.
There are several public key crypto systems, but one of the most popular is RSA.
In the RSA system, each person has a public key and a private key.
The security of the system is founded in the difficulty of factoring large numbers.

To make RSA feasible, we need the following two results.
\section*{Fast Modular Exponentiation}
How would we compute $8^{3039} \pmod{38}$?
We understand that one possible way of computing it would be
\[
8*8*8*8*\dots (3034 \text{ more times}) *8 \pmod{38}
\]
Calculating $8^8 = 16777216$!
Multiplying by $8$ each time leads to an enormous number which will finally be modded by $38$.
This will yield the answer $8^{3039} \equiv 18 \pmod{38}$.
However, we end up taking the mod of
\bignumber{
309364494429910569224074158373245871320261088338818839809516116319683937337824694639797484392553145921311162969795314687577878753945880788983648152672594156300105725702103009637521625346699102295126628430309215629345466680377322721095287151119548805982396859332324466726353415424546071554284880207769127903957788381101261257400404091967745307542578110867428754531803501942215597076795550293680355286384571026107363456179332767989089566141431697627745495677144792091971662774633776798836200145568167185652541589550330302123213629924085364016735796793885830988154309607850311898139167789375097602259381382514738805341423499721915190150925750938698512580223390713732486217483835134483607572569965309788063985462802989666308187452193771262040654008343868553985290751031810255880576927481663915122694568633300196828561130700545356768269280582187434534587197790354825628606664089599620772968794242997194172311333478650892585491058221492045784537878309096904862622869880014885551768545206544797116976074726344672493362695001481246347025291097347071973382250375852943818394695506599746738528681847642588807064370431862121741365676061233863942639392094469784702981369030250646812998461185633133467848986680638596314385337594273706701821800747548879458720019986682149146178685620334639282770904752914338826080860394274054737727003947974330004250338618843866592996192592830428423557692067769040096619828579638668400776746787256297380969946092270211524838778326711459996610641780767409606310642567660939458268000436251149254496654579604110657406568924179426470575501715013699220499232592923604442084548714023334631240982218358709753276420169139766405851160552486985275545321622498920625449176748818750710269694571141052545377449900581511454744120583816689607736846690232243393522342511186883894978304133143561241609992101663224030378192256447359110223366534769148676617094540983847686052547554325114060171112942592559843266410180826907725652938458795170564048598915083447841405646218536748421562297392006736931061215283387476058020858472263277569528893717205547768782193687332954106775185844759834817560367256170008829121239203290178930273790225520822117811256113731460192291020890045339125107445596097502290088470399019377018999927146843758630858434307599598944654022610984394045354982335998229899355619105759758299408946577503586191826628867086134833399462086170520653130187774421326917599586226987836827057382874569968377835965522866175136706353981372627380585333516862107939980976386191599775970968090528612429851830568492291708701684485778958412327410974829592671072270914520010627822203247436654805140288488799865758452727784199585943373090512798063591996432420346051711662890727147789447431115400966915927049391788520615997937437506978273276117123072}
Imagine if our exponent was hundreds of digits!
We could quickly run out of memory.

We can avoid dealing such huge numbers by doing the mod after each multiplication.
Doing the mod after each multiplication means that the largest number we have to deal with in this problem is 240.
In general, we wouldn't have to work with anything larger than $37^{2}$.
However, if we still have large exponent, the loop doing the multiplication would still have to run $3039$ iterations.

\begin{problem}
Write a function that will calculate $b^{e} \pmod{m}$.
Do not use Python's built-in power function.
\label{prob:naivepower}
\end{problem}

We need a faster better way.
The most common method of modular exponentiation is the \emph{right-to-left binary method}.
The essence of this method is to use the binary representation of the exponent.
We can quickly calculate the power up to the nearest power of two of the exponent.
This we simply calculate the remaining part the naieve way.

Calculating a modular exponent in this way leads to a very desirable $O(\log_2 e)$ runtime performance, where $e$ is the exponent.

\begin{problem}
Write a function that will perform modular exponentiation using the right-to-left binary method.
Compare the performance of \ref{prob:naivepower} and your new implementation.
Note that Python's built-in function, \li{pow()}, performs this type of fast modular exponentiation.
We expect you to use it instead of your own implementation in the future.
\label{prob:rlbpower}
\end{problem}

\section*{Fermat's Little Theorem}
An integral part of RSA relies on working with large prime numbers.
Prime numbers are numbers that are only divisible by 1 and the number itself.
In the RSA algorithms, we need to start with two prime numbers, $p$ and $q$.
We multiply these numbers to get $n=pq$ which is our modulus.
However, if $n$ is not that big, we can easily factor it, defeating the whole purpose of RSA.
The security of RSA largely reduces down to how well we choose starting primes.
If we pick primes that are too small, we sacrifice security.
How do we pick large primes?
We can use sieves to generate primes, but doing so would take lots of time and lots of memory.
It would be better if we could choose a number and determine if it is prime or not.

Fortunately, mathematics has developed a few tools that can help us out.
One of the first steps was given by Fermat.
\begin{theorem}[Fermat's Little Theorem]
If $p$ is prime, then for a natural number $a$, $a^{p-1} - 1 \equiv 0 \pmod{p}$
\end{theorem}
But, to use this we have start with a prime number.
However, if we have a candidate for $p$ and it satisifies the condition can we say anything about $p$?
The answer is yes, but we cannot say that $p$ is prime.
We can only say that $p$ might be prime.
\begin{example}
Suppose $p=37$.
We want to know if $p$ is prime.  We choose $a=8$.
\[
8^{36} - 1 \equiv 0 \pmod{37} 
\]
We call $8$ the witness number.  Think of as, \emph{$8$ says that $37$ is prime}.
This is the probabilistic part of Fermat's theorem.
We try enough witness numbers until we are convinced that our candidate number is prime.
Trying enough prime numbers, we will eventually be convinced that $37$ is prime, which it is.
\end{example}

\begin{example}
Let's check the primality of $1729$.
We will use $a=145$ as a witness number.
\[
145^{1728} \equiv 1 \pmod{1729}
\]
It appears that $1729$ is prime.
Let's try another witness number, $a=583$.
\[
583^{1728} \equiv 1 \pmod{1729}
\]
Let's try one last witness number, $a=945$.
\[
945^{1728} \equiv 742 \not\equiv 1 \pmod{1729}
\]
We have a problem.  
Our candidate is not behaving like we would expect a prime to behave.
But several witnesses verified that our number was prime.  What happened?
Our number, $1729$ is not really prime.  Its prime factors are $7$, $13$, and $19$. 
It is a special number called a Carmichael number.
Because of these numbers, we have to be careful with Fermat's Little Theorem.
More stringent primality tests exist, but are beyond the scope of this lab.
\end{example}
We have to remember that the Fermat test is really a test for compositeness, not primality.

\begin{problem}
For any candidate prime number, $n$, all the integers $2 \geq a < n$ can serve as a witness number.
Each of these possible witness numbers will either prove the compositeness of $n$ or give no information.
If we randomly choose a witness number, we will select a number in one of these two sets.
Supposing we chose a good random number generator, we can become convinced to a very high degree that $n$ is likely prime with just a few witness numbers.

Write a function that will return the number of witnesses that prove the compositeness of $n$.
What is the ratio of these witness numbers to all the numbers $2 \geq a < n$?
Suppose we were to choose witness numbers at random.  
How many random witness number must we choose to be $99$\% sure that $n$ is prime?
Remember that each new witness number increases the confidence that $n$ is probably prime.
\label{prob:prime_confidence}
\end{problem}

\section*{RSA Algorithm}
Bob wants to send a secret message to Alice.
Eve is trying to intercept this message.
Bob and Alice agree to use RSA to exchange the secret message.
Bob and Alice need to generate their keys.
Each generate a pair of keys, a private and a public one.
Both Bob and Alice need to keep their private keys secret.
Anyone with Alice's public key can send her a message that only she can decrypt.
Bob obtains a copy of Alice's pulic key and encrypt his message using it.
Alice decrypts Bob's message using her private key, and reads the message.

RSA involves generating a private key and a public key.

We begin by finding two large prime numbers.
By large, we mean several hundred digits.

RSA can be succinctly summarised as the following operations for encryption and decryption respectively
\[
c \equiv m^e \pmod{n}
\]
\[
m \equiv c^d \pmod{n}
\]

\begin{problem}
Generate a public/private key pair.

We do this by first multiplying the two primes, $p$ and $q$, together to get $n=pq$.
This will act as the modulus for future operations.
Next we need to choose an encryption exponent, $e$, such that $1 < e < \phi(n)$ and $\gcd(e, \phi(n)) = 1$.
Euler's totient function is 
Then our decryption exponent, $d$, must naturally be an inverse of $e$ mod $\phi(n)$.
In other words, we need $de \equiv 1 \pmod{\phi(n)}$.
You will need to write your own function that finds the inverse of $e$ mod $\phi(n)$ using the Extended Euclidean Algorithm.
We distribute $(e, n)$ as the public key and need to make sure that $(d, n)$ remains private.
After the keys are created, we have no further need of $p$ or $q$.
\end{problem}

Before we can encrypt and decrypt a text message, we need to convert it to a number first.
It is useful to understand the code below.
\begin{lstlisting}
# Recipe from itertools module in standard library
def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)
    
def a2i(msg):
    '''Convert an ASCII message to an integer.'''
    # bytearray will give us the ASCII values for each character
    if not isinstance(msg, bytearray):
        msg = bytearray(msg)
    binmsg = []
    # convert each character to binary
    for c in msg:
        binmsg.append(bin(c)[2:].zfill(8))
    return int(''.join(binmsg), 2)

def i2a(msg):
    '''Convert an integer to an ASCII message'''
    # convert to binary first
    binmsg = bin(msg)[2:]
    # we need to pad the message so length is divisible by 8
    binmsg = "0"*(8-(len(binmsg)%8)) + binmsg
    msg = bytearray()
    for block in grouper(binmsg, 8):
        # convert block of 8 bits back to ASCII
        msg.append(int(''.join(block), 2))
    return msg
\end{lstlisting}

\begin{problem}
Encrypt the message: \emph{Simon sells seashells by the seashore.}
Let $p=83285677$ and $q=2848968679$.
Choose $e=65593$.
Verify your encryption is correct by decrypting the message and checking the result.
\end{problem}

\section*{Breaking RSA}
Much of the security of RSA is dependent on the choices of numbers we use for encryption.
If we choose prime numbers or our encryption exponent incorrectly, we can seriously compromise the strength of RSA.

If our encryption exponent is too small, then it makes 

